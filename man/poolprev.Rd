% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/poolprev.R
\name{poolprev}
\alias{poolprev}
\title{Estimate prevalence from pooled test results}
\usage{
poolprev(
  data,
  method = "GP",
  spec = 1,
  sens_df = data.frame(n_tot = c(85, 85, 150, 150, 787, 38, 19, 72, 301, 80, 80, 80,
    4943, 452, 142, 142, 142, 152, 75, 51), n_pos = c(78, 64, 138, 126, 751, 30, 18, 64,
    226, 73, 74, 77, 4037, 437, 130, 116, 114, 129, 62, 49)),
  time.pred = NULL,
  prior = list(lambda = c(0, 2), alpha = c(0, 2), kappa = 10, logit_prev = c(-4, 2), sens
    = c(85, 15)),
  return.par = FALSE,
  return.stanfit = FALSE,
  ...
)
}
\arguments{
\item{data}{Datasets with the following variables:

\itemize{
\item time. Time (should be numeric)
\item pop. Population name (if missing, it assumes an unique population to analyse)
\item pool.size. Pool size (number of samples by pool)
\item n.pools. Number of pools
\item n.pos.pools. Number of positive pools.
}}

\item{method}{Method used to analyse data ("timepoint" or "GP").}

\item{spec}{Test specificity.}

\item{sens_df}{A data frame containing test sensitivity data.}

\item{time.pred}{Only when \code{method="GP"}. Times at which prevalence is predicted.}

\item{prior}{A list of values for prior hyperparameters.}

\item{return.par}{A logical indicating whether to return GP parameter estimates.}

\item{return.stanfit}{A logical indicating whether to return the stan model.}

\item{...}{Arguments passed to \code{rstan::sampling} (e.g. iter, chains). If there are divergences,
add \code{control=list(adapt_delta=0.99)}.}
}
\value{
A list containing the following elements:
\itemize{
\item \code{prev}. A data frame displaying estimated prevalence over time (and populations).
\item \code{prev_ratio}. Ratio between two consecutive prevalence estimates.
\item \code{mod_par}. Estimates of some model parameters (returned if \code{return.par} is \code{TRUE}).
\item \code{sampler_par}. Stan diagnosis parameters (returned if \code{return.par} is \code{TRUE}).
\item \code{time}. Stan sampling time (returned if \code{return.par} is \code{TRUE}).
\item \code{stanfit}. \code{stanfit} object (returned if \code{return.stanfit} is \code{TRUE}).
}
}
\description{
\code{poolprev} is used to estimate prevalence from pooled test results over time.
It fits a Bayesian model using the Stan framework.
}
\details{
\strong{Models}

Two models are implemented, which differ in the way the correlation over time is handled.

In the default model (selected by setting \code{method="GP"}), a hidden Gaussian process (GP) model the true prevalence in order to take the correlation over time into account.
The \code{GP} method uses a squared exponential kernel to characterize the correlation of the GP.
This basically assumes that the correlation between the prevalence of two timepoints only depends on the distance between the timepoints (i.e. the time difference).
Two parameters are used to model the squared exponential kernel (also known as "exponentiated quadratic kernel"): the lengthscale \code{lambda} and the output variance \code{alpha^2}.
The lengthscale \code{lambda} determines the length of the "wiggles".
The output variance \code{alpha^2} is a scale factor that determines the average distance between the realizations of the GP.
It characterizes the variance of the prevalence over time.

The second (more basic) model (selected by setting \code{method="timepoint"}) estimates the prevalence at each timepoint without considering any correlation over time.
It assumes one parameter for each timepoint in order to estimate the prevalence over time.
The \code{timepoint} model is provided for the sake of comparison but the \code{GP} model should generally be preferred.

\strong{Specificity and sensitivity}

The models adjust for imperfect test sensitivity and specificity.
The test specificity is assumed to be fixed and can be specified through the \code{spec} argument (default is 100\%).

The test sensitivity is fitted together with the prevalence parameters using data from test sensitivity studies.
This data are specified through the \code{sens_df} argument.
\code{sens_df} should be a data frame, where each row represents a study, and it should contains two columns named \code{n_tot} and \code{n_pos}.
The \code{n_tot} column should report the number of samples tested for sensitivity in a given study and the \code{n_pos} column the number of positive samples.
By default, the model uses test sensitivity data from Marando et al. (2022), which includes results from 20 sub-studies investigating the sensitivity of RT-PCR SARS-CoV-2 tests.

\strong{Inference}

The models calculate the pool test positivity over time from the prevalence (and the pool sizes \code{pool.size} given in \code{data}).
It assumes that the number of positive pools \code{n.pos.pools} follow a binomial distribution with probability being the test positivity.

When multiple pooled test results are provided for at least one timepoint (for the same population), the model replace the binomial distribution a beta-binomial distribution.
Overdispersion is characterized with the \code{kappa} parameter.

If the \code{pop} column in the \code{data} argument is absent, the model assumes only one population (i.e. it models one prevalence over time).
If it is provided, the models estimate the prevalence over time for each of the populations present in \code{data}.
This allows for a unique (and simultaneous) estimation of the sensitivity.
The user should however consider running the populations separately, if some issues about the convergence of the Stan model are observed.

\strong{Priors}

The priors can be specified through the \code{prior} argument, which a named list of vectors containing the hyperparameters of the priors.
The names of the elements in the list should match with the names of the parameters.

The lengthscale \code{lambda} has truncated normal prior distribution with default mean of 0 and standard deviation of 2.
The output standard deviation \code{alpha} has a truncated normal prior with default mean of 0 and standard deviation of 2.
The prior of the overdispersion \code{kappa} is obtained by adding \code{2} to an exponential distribution with default mean of 10.
The parameter representing the average prevalence \code{logit_prev} has logit-normal prior, with default mean of -4 and standard deviation of 2.
This corresponds to an average prevalence of 1.8\% with 95\% confidence intervals (CI) of (0.3\%,48\%).
The sensitivity \code{sens} has a beta prior distribution whose default hyperparameters are respectively 85 and 15.
This corresponds to a mean of approximately 85\% and with 95\% CI of (77.4\%, 91.3\%).

\strong{Predictions}

For \code{method="GP"}, the function can provide predictions of the prevalence at times \code{time.pred}.
By default (i.e., when the argument \code{time.pred} is not specified), the model only estimates the prevalence at all the times present in the data.
}
\examples{

######################
#Example 1: estimated the prevalence over time of a population from data with imperfect test sensitivity
#load data
data(epipool_data1)

#run model with method assuming a prevalence parameter every week
out_timepoint = poolprev(epipool_data1[[1]], method="timepoint", spec=1, return.par=TRUE,return.stanfit=FALSE) #takes a few seconds
#run model with Gaussian process
out_GP = poolprev(epipool_data1[[1]], method="GP", spec=1, return.par=TRUE,return.stanfit=FALSE) #can take a few minutes

#plot
library(ggplot2)
library(dplyr)
dplyr::left_join(epipool_data1[[1]],
             rbind(out_timepoint$prev \%>\% dplyr::mutate(method="timepoint"),
                   out_GP$prev \%>\% dplyr::mutate(method="GP")),multiple = "all",
             by="time") \%>\%
ggplot(aes(x=time))+
geom_ribbon(aes(ymin=lwr,ymax=upr),fill="black",alpha=0.1)+
geom_line(aes(y=mean),col="black",linewidth=0.8)+
geom_point(aes(y=mean),col="black",linewidth=2)+
geom_point(aes(y=prev),col="red",linewidth=2) +
facet_grid(.~method) +
theme_bw() +
scale_y_continuous(name="Prevalence", labels = scales::percent)

######################
#Example 2: estimate the prevalence of two populations from data with imperfect test sensitivity and specificity
#load data
data(epipool_data2)
data(epipool_data3)
data = rbind(epipool_data2[[1]] \%>\% dplyr::mutate(pop="pop1"),
         epipool_data3[[1]] \%>\% dplyr::mutate(pop="pop2"))

#run model with GP
out_timepoint = poolprev(data, method="timepoint", return.par=TRUE) #takes a few seconds
out_GP1 = poolprev(data, method="GP", spec=0.999, return.par=TRUE) #can take a few minutes
out_GP2 = poolprev(data, method="GP", spec=0.999, prior=list(lambda=c(0,1),alpha=c(0,1)),
               return.par=TRUE) #can take a few minutes

#plot prevalence
library(ggplot2)
left_join(data,
      rbind(out_timepoint$prev \%>\% dplyr::mutate(method="timepoint"),
            out_GP1$prev \%>\% dplyr::mutate(method="GP"),
            out_GP2$prev \%>\% dplyr::mutate(method="GP with smaller lengthscale/sd priors")),
      multiple = "all",
          by=c("time","pop")) \%>\%
  ggplot(aes(x=time))+
  geom_ribbon(aes(ymin=lwr,ymax=upr),fill="black",alpha=0.1)+
  geom_line(aes(y=mean),col="black",size=0.8)+
  geom_point(aes(y=mean),col="black",size=2)+
  geom_point(aes(y=prev),col="red",size=2) +
  facet_grid(method~pop) +
  theme_bw() +
  scale_y_continuous(name="Prevalence", labels = scales::percent)

#compare parameter estimates
print(out_timepoint$par)
print(out_GP1$par)
print(out_GP2$par)
}
